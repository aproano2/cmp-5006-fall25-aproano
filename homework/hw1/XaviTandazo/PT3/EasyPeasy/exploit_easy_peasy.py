#!/usr/bin/env python3
#exploit_easy_peasy.py
import socket, re

HOST = "mercury.picoctf.net"
PORT = 58913
KEY_LEN = 50000

def recv_until_prompt(s, prompt=b"What data would you like to encrypt? "):
    data = b""
    try:
        while True:
            chunk = s.recv(4096)
            if not chunk:
                break
            data += chunk
            if prompt in data:
                break
    except Exception:
        pass
    return data

def longest_hex_group(b):
    groups = re.findall(rb"[0-9a-fA-F]+", b)
    if not groups:
        return None
    best = max(groups, key=len)
    if len(best) % 2 != 0:
        best = best[:-1]
    try:
        return bytes.fromhex(best.decode())
    except Exception:
        return None

def try_all_bytes():
    s = socket.create_connection((HOST, PORT))  #nosotros abrimos la conexión al servicio remoto
    s.settimeout(6.0)

    # leer hasta el primer prompt que contiene cifrado de la flag
    initial = recv_until_prompt(s)
    print("[debug] inicio (primeros 300 chars):")
    print(initial[:300].decode(errors='ignore'))
    cipher_flag = longest_hex_group(initial)  #extraemos el hex más largo que corresponde al cifrado de la flag
    if cipher_flag is None:
        print("No pude extraer el cifrado de la flag.")
        return
    F = len(cipher_flag)  #aqui se determina la longitud de la flag en bytes
    print(f"Longitud de la flag (estimada): {F} bytes")
    print("Cifrado de la flag (hex):", cipher_flag.hex())

    # avanzar puntero hasta wrap
    pad_len = (KEY_LEN - F) % KEY_LEN  #se calcula cuanto padding hace falta para que la clave haga wrap y vuelva a 0
    print("Enviando padding:", pad_len)
    s.sendall(b"A" * pad_len + b"\n")  #enviamos padding para mover key_location al inicio
    _ = recv_until_prompt(s)

    candidates = []
    # probar todos los bytes 0..255
    for k in range(256):
        known = bytes([k]) * F
        s.sendall(known + b"\n")  #se pide cifrar un texto conocido repetido de longitud F
        after = recv_until_prompt(s)
        cipher_known = longest_hex_group(after)  #se extrae el cifrado del texto conocido
        if cipher_known is None or len(cipher_known) < F:
            #satamos si no se extrae bien
            continue
        # ajustar longitudes
        L = min(len(cipher_flag), len(cipher_known))
        cf = cipher_flag[:L]
        ck = cipher_known[:L]
        # flag = cf XOR ck XOR knownbyte
        flag_bytes = bytes([a ^ b ^ k for (a,b) in zip(cf, ck)])  #calculamos los bytes de la flag usando XOR entre ambos cifrados y el known
        # condiciones para seleccionar candidato:
            # - contiene "pico" o "CTF" o '{' o '}' OR
            # - es totalmente imprimible ASCII y longitud razonable
        text = None
        try:
            text = flag_bytes.decode('utf-8')
        except:
            text = None
        printable = False
        if text:
            #criterio simple de imprimibilidad
            if all(32 <= ord(ch) <= 126 for ch in text):
                printable = True
        if (text and ("pico" in text.lower() or "ctf" in text.lower() or "{" in text or "}" in text)) or printable:
            candidates.append((k, flag_bytes, text))

    s.close()
    if not candidates:
        # si no hay candidatos obvios, intentamos con 'B' como fallback y mostramos su resultado
        k = ord('B')
        s2 = socket.create_connection((HOST, PORT))  #aqui reabrimos la conexión para repetir el proceso desde el inicio
        s2.settimeout(6.0)
        _ = recv_until_prompt(s2)
        _ = recv_until_prompt(s2)
        cipher_flag = longest_hex_group(_)  #volvemos a leer el cifrado de la flag en la nueva conexión
        s2.sendall(b"A" * pad_len + b"\n")  #reenviamos el padding para forzar el wrap
        _ = recv_until_prompt(s2)
        s2.sendall(bytes([k]) * F + b"\n")  #enviamos el known con 'B' repetido
        after = recv_until_prompt(s2)
        ck = longest_hex_group(after)  #extraemos el cifrado del known en la reconexión
        s2.close()
        if ck:
            L = min(len(cipher_flag), len(ck))
            flag_bytes = bytes([a ^ b ^ k for (a,b) in zip(cipher_flag[:L], ck[:L])])  #calculamos la flag con el fallback
            try:
                text = flag_bytes.decode('utf-8')
            except:
                text = None
            print(flag_bytes.hex())
            if text:
                print(text)
            else:
                print(repr(flag_bytes))
    else:
        #mostramos el mejor candidato
        first_k, first_bytes, first_text = candidates[0]
        print(first_bytes.hex())
        if first_text:
            print(first_text)

if __name__ == "__main__":
    try_all_bytes()
